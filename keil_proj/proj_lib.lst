C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:35:22 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROJ_LIB
OBJECT MODULE PLACED IN proj_lib.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\proj_lib.c ROM(COMPACT) BROWSE INCDIR(.\source) DEBUG OBJECTEXTEND P
                    -RINT(.\proj_lib.lst) TABS(2) OBJECT(proj_lib.obj)

line level    source

   1          #include "proj_lib.h"
   2          
   3          //---------------------------------------------------------------------------
   4          // Global Variable Define
   5          //---------------------------------------------------------------------------
   6          u16  time_ms;
   7          u16  time_qua;
   8          u16  time_sec;
   9          u8   fsm;
  10          u8   us0_frash;
  11          u8   us1_frash;
  12          u16  us0_meas[4];
  13          u16  us1_meas[4];
  14          STRUCT_INT_CNT data st_x0;
  15          STRUCT_INT_CNT data st_x1;
  16          STRUCT_INT_CNT data st_t0;
  17          STRUCT_INT_CNT data st_t1;
  18          STRUCT_INT_CNT data *st_p;
  19          
  20          //---------------------------------------------------------------------------
  21          // Check struct increased by interrupt
  22          //---------------------------------------------------------------------------
  23          u8 inc_check (STRUCT_INT_CNT *p)
  24          {
  25   1          u8 cur;
  26   1          cur = p->cnt;
  27   1          if (cur > p->bak)       // normal increase
  28   1          {
  29   2              cur = cur - p->bak;
  30   2              p->bak = p->cnt;
  31   2          }
  32   1          else if (cur < p->bak)  // overflow increase
  33   1          {
  34   2              cur = 256 - p->bak + cur;
  35   2              p->bak = p->cnt;
  36   2          }
  37   1          else                    // no increase
  38   1          {
  39   2              cur = 0;
  40   2          }
  41   1          return cur;
  42   1      }
  43          
  44          //---------------------------------------------------------------------------
  45          // Initial System
  46          //---------------------------------------------------------------------------
  47          void sys_init (void)
  48          {
  49   1          // device init
  50   1          LcdInit ();
  51   1          mcu_init ();
  52   1          // parameter init
  53   1          st_x0.cnt = 0;
  54   1          st_x0.bak = 0;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:35:22 PAGE 2   

  55   1          st_x1.cnt = 0;
  56   1          st_x1.bak = 0;
  57   1          st_t0.cnt = 0;
  58   1          st_t0.bak = 0;
  59   1          st_t1.cnt = 0;
  60   1          st_t1.bak = 0;
  61   1          us0_frash = 0;
  62   1          us1_frash = 0;
  63   1          us0_meas[0] = 0;
  64   1          us0_meas[1] = 0;
  65   1          us0_meas[2] = 0;
  66   1          us0_meas[3] = 0;
  67   1          us1_meas[0] = 0;
  68   1          us1_meas[1] = 0;
  69   1          us1_meas[2] = 0;
  70   1          us1_meas[3] = 0;
  71   1          time_ms = 0;
  72   1          time_qua = 0;
  73   1          time_sec = 0;
  74   1          us0_trig = 0;
  75   1          us1_trig = 0;
  76   1          EA = 1;
  77   1      }
  78          
  79          //---------------------------------------------------------------------------
  80          // Trigger one measurement of untrasonic 0
  81          //---------------------------------------------------------------------------
  82          #ifdef EN_US0
              void fsm_tus0_proc(void)
              {
                  u8 i, j;
                  // set 
                  time_ms = 0;
                  mcu_set_exint (INT_IDX_0, INT_MOD_START);
                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP );
                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_CAP  );
                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_50MS );
                  // start us0
                  us0_trig = 1;
                  DelayUs(100);
                  us0_trig = 0;
                  // detect
                  while (1)
                  {
                      // check response
                      i = inc_check (&st_x0);
                      if (i>0)
                      {
                          // stop
                          mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
                          mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
                          if (i==1)   // normal response
                          {
                              // backup response
                              for(j=0; j<3; j++)
                              {
                                  us0_meas[j+1] = us0_meas[j];
                              }
                              us0_meas[0] = (TH0<<8) + TL0;
                              us0_frash = 1;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:35:22 PAGE 3   

                              // record time
                              time_ms = time_ms + (((TH1<<8) + TL1)*2)/1000;
                              // jump to next state
                              fsm = FSM_TUS1;
                              break;
                          }
                          else
                          {
                              // record time
                              time_ms = time_ms + (((TH1<<8) + TL0)*2)/1000;
                              // jump to error state
                              fsm = FSM_ERR_US0_MULTI_RESP;
                              break;
                          }
                      }
                      // check timeout
                      i = inc_check (&st_t1);
                      if (i>0)
                      {
                          // stop
                          mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
                          mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
                          time_ms = time_ms + 50;
                          fsm = FSM_ERR_US0_TIMEOUT;
                          break;
                      }
                  }
              }
              #else
 148          void fsm_tus0_proc(void)
 149          {
 150   1          time_ms = 0;
 151   1          fsm = FSM_TUS1;
 152   1      }
 153          #endif
 154          
 155          //---------------------------------------------------------------------------
 156          // Trigger one measurement of untrasonic 1
 157          //---------------------------------------------------------------------------
 158          #ifdef EN_US1
 159          void fsm_tus1_proc(void)
 160          {
 161   1          u8 i, j;
 162   1          // set 
 163   1          mcu_set_exint (INT_IDX_0, INT_MOD_STOP );
 164   1          mcu_set_exint (INT_IDX_1, INT_MOD_START);
 165   1          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_50MS );
 166   1          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_CAP  );
 167   1          // start us0
 168   1          us1_trig = 1;
 169   1          DelayUs(100);
 170   1          us1_trig = 0;
 171   1          // detect
 172   1          while (1)
 173   1          {
 174   2              // check response
 175   2              i = inc_check (&st_x1);
 176   2              if (i>0)
 177   2              {
 178   3                  // stop
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:35:22 PAGE 4   

 179   3                  mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
 180   3                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 181   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 182   3                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 183   3                  if (i==1)   // normal response
 184   3                  {
 185   4                      // backup response
 186   4                      for(j=0; j<3; j++)
 187   4                      {
 188   5                          us1_meas[j+1] = us1_meas[j];
 189   5                      }
 190   4                      us1_meas[0] = (TH1<<8) + TL1;
 191   4                      us1_frash = 1;
 192   4                      // record time
 193   4                      time_ms = time_ms + (((TH0<<8) + TL0)*2)/1000;
 194   4                      // jump to next state
 195   4                      fsm = FSM_WAIT;
 196   4                      break;
 197   4                  }
 198   3                  else
 199   3                  {
 200   4                      // record time
 201   4                      time_ms = time_ms + (((TH0<<8) + TL0)*2)/1000;
 202   4                      // jump to error state
 203   4                      fsm = FSM_ERR_US1_MULTI_RESP;
 204   4                      break;
 205   4                  }
 206   3              }
 207   2              // check timeout
 208   2              i = inc_check (&st_t0);
 209   2              if (i>0)
 210   2              {
 211   3                  // stop
 212   3                  mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
 213   3                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 214   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 215   3                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 216   3                  time_ms = time_ms + 50;
 217   3                  fsm = FSM_ERR_US1_TIMEOUT;
 218   3                  break;
 219   3              }
 220   2          }
 221   1      }
 222          #else
              void fsm_tus1_proc(void)
              {
                  time_ms = time_ms;
                  fsm = FSM_WAIT;
              }
              #endif
 229          
 230          //---------------------------------------------------------------------------
 231          // Wait for 250ms, and process the result of measurement
 232          //---------------------------------------------------------------------------
 233          void fsm_wait_proc(void)
 234          {
 235   1          u8 i, j;
 236   1          u16 len;
 237   1          // 250ms timer
 238   1          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_10MS);
 239   1          while (1)
 240   1          {
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:35:22 PAGE 5   

 241   2              i = inc_check (&st_t0);
 242   2              time_ms = time_ms + i*10;
 243   2              if (time_ms > 250)
 244   2              {
 245   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 246   3                  time_qua = time_qua + 1;
 247   3                  break;
 248   3              }
 249   2          }
 250   1          // frash flag
 251   1          us0_frash = 0;
 252   1          us1_frash = 0;
 253   1          // refrash display each second
 254   1          if (time_qua == 4)
 255   1          {
 256   2              time_qua = 0;
 257   2              time_sec = time_sec + 1;
 258   2              // display time
 259   2              i = time_sec/10000 + '0';
 260   2              j = time_sec%10000;
 261   2              LcdDispChar (1, 10, i);
 262   2              i = j/1000 + '0';
 263   2              j = j%1000;
 264   2              LcdDispChar (1, 11, i);
 265   2              i = j/100 + '0';
 266   2              j = j%100;
 267   2              LcdDispChar (1, 12, i);
 268   2              i = j/10 + '0';
 269   2              j = j%10;
 270   2              LcdDispChar (1, 13, i);
 271   2              LcdDispChar (1, 14, j);
 272   2              // display us0
 273   2              len = (us0_meas[0] + us0_meas[1] + us0_meas[2] + us0_meas[3])/2;    // time in us
 274   2              len = len/2;        // single trace
 275   2              len = len/1000;     // time in ms
 276   2              len = len * 340;    // length in mm
 277   2              i = len/10000 + '0';
 278   2              j = len%10000;
 279   2              LcdDispChar (0, 0, i);
 280   2              i = j/1000 + '0';
 281   2              j = j%1000;
 282   2              LcdDispChar (0, 1, i);
 283   2              i = j/100 + '0';
 284   2              j = j%100;
 285   2              LcdDispChar (0, 2, i);
 286   2              i = j/10 + '0';
 287   2              j = j%10;
 288   2              LcdDispChar (0, 3, i);
 289   2              LcdDispChar (0, 4, j);
 290   2              // display us1
 291   2              len = (us1_meas[0] + us1_meas[1] + us1_meas[2] + us1_meas[3])/2;    // time in us
 292   2              len = len/2;        // single trace
 293   2              len = len/1000;     // time in ms
 294   2              len = len * 340;    // length in mm
 295   2              i = len/10000 + '0';
 296   2              j = len%10000;
 297   2              LcdDispChar (1, 0, i);
 298   2              i = j/1000 + '0';
 299   2              j = j%1000;
 300   2              LcdDispChar (1, 1, i);
 301   2              i = j/100 + '0';
 302   2              j = j%100;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:35:22 PAGE 6   

 303   2              LcdDispChar (1, 2, i);
 304   2              i = j/10 + '0';
 305   2              j = j%10;
 306   2              LcdDispChar (1, 3, i);
 307   2              LcdDispChar (1, 4, j);
 308   2          }
 309   1          fsm = FSM_TUS0;
 310   1      }
 311          
 312          //---------------------------------------------------------------------------
 313          // Display Error Message
 314          //---------------------------------------------------------------------------
 315          void fsm_erro_proc(void)
 316          {
 317   1          u8 i;
 318   1          // 1. clear screen
 319   1          for (i=0; i<16; i++)
 320   1              LcdDispChar (0, i, ' ');
 321   1          for (i=0; i<16; i++)
 322   1              LcdDispChar (1, i, ' ');
 323   1          // 2. display "FSM ERROR!"
 324   1          LcdDispString (0, 0, "FSM ERROR!!!");
 325   1          LcdDispChar (1, 0, 'f');
 326   1          LcdDispChar (1, 1, 's');
 327   1          LcdDispChar (1, 2, 'm');
 328   1          LcdDispChar (1, 3, ':');
 329   1          LcdDispChar (1, 4, ('0'+fsm/100));
 330   1          LcdDispChar (1, 5, ('0'+(fsm%100)/10));
 331   1          LcdDispChar (1, 6, ('0'+fsm%10));
 332   1          LcdDispChar (1, 7, 'd');
 333   1          // 3. stay here
 334   1          fsm = fsm;
 335   1      }
 336          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1211    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
