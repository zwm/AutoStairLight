C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:14:34 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROJ_LIB
OBJECT MODULE PLACED IN proj_lib.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\proj_lib.c ROM(COMPACT) BROWSE INCDIR(.\source) DEBUG OBJECTEXTEND P
                    -RINT(.\proj_lib.lst) TABS(2) OBJECT(proj_lib.obj)

line level    source

   1          #include "proj_lib.h"
   2          
   3          //---------------------------------------------------------------------------
   4          // Global Variable Define
   5          //---------------------------------------------------------------------------
   6          //uint16  time_ms;
   7          u16  time_ms;
   8          u16  time_qua;
   9          u16  time_sec;
  10          u8   fsm;
  11          u8   us0_frash;
  12          u8   us1_frash;
  13          u16  us0_meas[4];
  14          u16  us1_meas[4];
  15          STRUCT_INT_CNT data st_x0;
  16          STRUCT_INT_CNT data st_x1;
  17          STRUCT_INT_CNT data st_t0;
  18          STRUCT_INT_CNT data st_t1;
  19          STRUCT_INT_CNT data *st_p;
  20          
  21          //---------------------------------------------------------------------------
  22          // Global Variable Define
  23          //---------------------------------------------------------------------------
  24          unsigned char inc_check (STRUCT_INT_CNT *p)
  25          {
  26   1          unsigned char cur;
  27   1          cur = p->cnt;
  28   1          if (cur > p->bak)       // normal increase
  29   1          {
  30   2              p->bak = cur;
  31   2              cur = cur - p->bak;
  32   2          }
  33   1          else if (cur < p->bak)  // overflow increase
  34   1          {
  35   2              p->bak = cur;
  36   2              cur = 256 - p->bak + cur;
  37   2          }
  38   1          else                    // no increase
  39   1          {
  40   2              cur = 0;
  41   2          }
  42   1          return cur;
  43   1      }
  44          
  45          void sys_init (void)
  46          {
  47   1          // device init
  48   1          LcdInit ();
  49   1          mcu_init ();
  50   1          // parameter init
  51   1          st_x0.cnt = 0;
  52   1          st_x0.bak = 0;
  53   1          st_x1.cnt = 0;
  54   1          st_x1.bak = 0;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:14:34 PAGE 2   

  55   1          st_t0.cnt = 0;
  56   1          st_t0.bak = 0;
  57   1          st_t1.cnt = 0;
  58   1          st_t1.bak = 0;
  59   1          us0_frash = 0;
  60   1          us1_frash = 0;
  61   1          us0_meas[0] = 0;
  62   1          us0_meas[1] = 0;
  63   1          us0_meas[2] = 0;
  64   1          us0_meas[3] = 0;
  65   1          us1_meas[0] = 0;
  66   1          us1_meas[1] = 0;
  67   1          us1_meas[2] = 0;
  68   1          us1_meas[3] = 0;
  69   1          time_ms = 0;
  70   1          time_qua = 0;
  71   1          time_sec = 0;
  72   1          us0_trig = 0;
  73   1          us1_trig = 0;
  74   1          EA = 1;
  75   1      }
  76          
  77          void fsm_tus0_proc(void)
  78          {
  79   1          unsigned char i, j;
  80   1          // set 
  81   1          time_ms = 0;
  82   1          mcu_set_exint (INT_IDX_0, INT_MOD_START);
  83   1          mcu_set_exint (INT_IDX_1, INT_MOD_STOP );
  84   1          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_CAP  );
  85   1          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_50MS );
  86   1          // start us0
  87   1          us0_trig = 1;
  88   1          DelayUs(100);
  89   1          us0_trig = 0;
  90   1          // detect
  91   1          while (1)
  92   1          {
  93   2              // check response
  94   2              i = inc_check (&st_x0);
  95   2              if (i>0)
  96   2              {
  97   3                  // stop
  98   3                  mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
  99   3                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 100   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 101   3                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 102   3                  if (i==1)   // normal response
 103   3                  {
 104   4                      // backup response
 105   4                      for(j=0; j<3; j++)
 106   4                      {
 107   5                          us0_meas[j+1] = us0_meas[j];
 108   5                      }
 109   4                      us0_meas[0] = (TH0<<8) + TL0;
 110   4                      us0_frash = 1;
 111   4                      // record time
 112   4                      time_ms = time_ms + (((TH1<<8) + TL1)*2)/1000;
 113   4                      // jump to next state
 114   4                      fsm = FSM_TUS1;
 115   4                      break;
 116   4                  }
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:14:34 PAGE 3   

 117   3                  else
 118   3                  {
 119   4                      // record time
 120   4                      time_ms = time_ms + (((TH1<<8) + TL0)*2)/1000;
 121   4                      // jump to error state
 122   4                      fsm = FSM_ERR_US0_MULTI_RESP;
 123   4                      break;
 124   4                  }
 125   3              }
 126   2              // check timeout
 127   2              i = inc_check (&st_t1);
 128   2              if (i>0)
 129   2              {
 130   3                  // stop
 131   3                  mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
 132   3                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 133   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 134   3                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 135   3                  time_ms = time_ms + 50;
 136   3                  fsm = FSM_ERR_US0_TIMEOUT;
 137   3                  break;
 138   3              }
 139   2          }
 140   1      }
 141          void fsm_tus1_proc(void)
 142          {
 143   1          unsigned char i, j;
 144   1          // set 
 145   1          mcu_set_exint (INT_IDX_0, INT_MOD_STOP );
 146   1          mcu_set_exint (INT_IDX_1, INT_MOD_START);
 147   1          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_50MS );
 148   1          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_CAP  );
 149   1          // start us0
 150   1          us1_trig = 1;
 151   1          DelayUs(100);
 152   1          us1_trig = 0;
 153   1          // detect
 154   1          while (1)
 155   1          {
 156   2              // check response
 157   2              i = inc_check (&st_x1);
 158   2              if (i>0)
 159   2              {
 160   3                  // stop
 161   3                  mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
 162   3                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 163   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 164   3                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 165   3                  if (i==1)   // normal response
 166   3                  {
 167   4                      // backup response
 168   4                      for(j=0; j<3; j++)
 169   4                      {
 170   5                          us1_meas[j+1] = us1_meas[j];
 171   5                      }
 172   4                      us1_meas[0] = (TH1<<8) + TL1;
 173   4                      us1_frash = 1;
 174   4                      // record time
 175   4                      time_ms = time_ms + (((TH0<<8) + TL0)*2)/1000;
 176   4                      // jump to next state
 177   4                      fsm = FSM_WAIT;
 178   4                      break;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:14:34 PAGE 4   

 179   4                  }
 180   3                  else
 181   3                  {
 182   4                      // record time
 183   4                      time_ms = time_ms + (((TH0<<8) + TL0)*2)/1000;
 184   4                      // jump to error state
 185   4                      fsm = FSM_ERR_US1_MULTI_RESP;
 186   4                      break;
 187   4                  }
 188   3              }
 189   2              // check timeout
 190   2              i = inc_check (&st_t0);
 191   2              if (i>0)
 192   2              {
 193   3                  // stop
 194   3                  mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
 195   3                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 196   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 197   3                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 198   3                  time_ms = time_ms + 50;
 199   3                  fsm = FSM_ERR_US1_TIMEOUT;
 200   3                  break;
 201   3              }
 202   2          }
 203   1      }
 204          void fsm_wait_proc(void)
 205          {
 206   1          uchar i, j;
 207   1          uint16 len;
 208   1          // 250ms timer
 209   1          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_10MS);
 210   1          while (1)
 211   1          {
 212   2              i = inc_check (&st_t0);
 213   2              time_ms = time_ms + i*10;
 214   2              if (time_ms > 250)
 215   2              {
 216   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 217   3                  time_qua = time_qua + 1;
 218   3                  break;
 219   3              }
 220   2          }
 221   1      
 222   1          // frash flag
 223   1          us0_frash = 0;
 224   1          us1_frash = 0;
 225   1      
 226   1          // refrash display each second
 227   1          if (time_qua == 4)
 228   1          {
 229   2              time_qua = 0;
 230   2              time_sec = time_sec + 1;
 231   2              // display time
 232   2              i = time_sec/10000 + '0';
 233   2              j = time_sec%10000;
 234   2              LcdDispChar (1, 10, i);
 235   2              i = j/1000 + '0';
 236   2              j = j%1000;
 237   2              LcdDispChar (1, 11, i);
 238   2              i = j/100 + '0';
 239   2              j = j%100;
 240   2              LcdDispChar (1, 12, i);
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:14:34 PAGE 5   

 241   2              i = j/10 + '0';
 242   2              j = j%10;
 243   2              LcdDispChar (1, 13, i);
 244   2              LcdDispChar (1, 14, j);
 245   2              // display us0
 246   2              len = (us0_meas[0] + us0_meas[1] + us0_meas[2] + us0_meas[3])/2;    // time in us
 247   2              len = len/2;        // single trace
 248   2              len = len/1000;     // time in ms
 249   2              len = len * 340;    // length in mm
 250   2              i = len/10000 + '0';
 251   2              j = len%10000;
 252   2              LcdDispChar (0, 0, i);
 253   2              i = j/1000 + '0';
 254   2              j = j%1000;
 255   2              LcdDispChar (0, 1, i);
 256   2              i = j/100 + '0';
 257   2              j = j%100;
 258   2              LcdDispChar (0, 2, i);
 259   2              i = j/10 + '0';
 260   2              j = j%10;
 261   2              LcdDispChar (0, 3, i);
 262   2              LcdDispChar (0, 4, j);
 263   2              // display us1
 264   2              len = (us1_meas[0] + us1_meas[1] + us1_meas[2] + us1_meas[3])/2;    // time in us
 265   2              len = len/2;        // single trace
 266   2              len = len/1000;     // time in ms
 267   2              len = len * 340;    // length in mm
 268   2              i = len/10000 + '0';
 269   2              j = len%10000;
 270   2              LcdDispChar (1, 0, i);
 271   2              i = j/1000 + '0';
 272   2              j = j%1000;
 273   2              LcdDispChar (1, 1, i);
 274   2              i = j/100 + '0';
 275   2              j = j%100;
 276   2              LcdDispChar (1, 2, i);
 277   2              i = j/10 + '0';
 278   2              j = j%10;
 279   2              LcdDispChar (1, 3, i);
 280   2              LcdDispChar (1, 4, j);
 281   2          }
 282   1          fsm = FSM_TUS0;
 283   1      }
 284          
 285          // fall in error state
 286          void fsm_erro_proc(void)
 287          {
 288   1          unsigned char i;
 289   1          // 1. clear screen
 290   1          for (i=0; i<16; i++)
 291   1              LcdDispChar (0, i, ' ');
 292   1          for (i=0; i<16; i++)
 293   1              LcdDispChar (1, i, ' ');
 294   1          // 2. display "FSM ERROR!"
 295   1          LcdDispString (0, 0, "FSM ERROR!!!");
 296   1          LcdDispChar (1, 0, 'f');
 297   1          LcdDispChar (1, 1, 's');
 298   1          LcdDispChar (1, 2, 'm');
 299   1          LcdDispChar (1, 3, ':');
 300   1          LcdDispChar (1, 4, ('0'+fsm/100));
 301   1          LcdDispChar (1, 5, ('0'+(fsm%100)/10));
 302   1          LcdDispChar (1, 6, ('0'+fsm%10));
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/05/2018 12:14:34 PAGE 6   

 303   1          LcdDispChar (1, 7, 'd');
 304   1          // 3. stay here
 305   1          fsm = fsm;
 306   1      }
 307          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1490    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
