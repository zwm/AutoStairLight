C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/07/2018 15:49:20 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROJ_LIB
OBJECT MODULE PLACED IN proj_lib.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\proj_lib.c ROM(COMPACT) BROWSE INCDIR(.\source) DEBUG OBJECTEXTEND P
                    -RINT(.\proj_lib.lst) TABS(2) OBJECT(proj_lib.obj)

line level    source

   1          #include "proj_lib.h"
   2          
   3          //---------------------------------------------------------------------------
   4          // Global Variable Define
   5          //---------------------------------------------------------------------------
   6          volatile u16  time_ms;
   7          volatile u16  time_qua;
   8          volatile u16  time_sec;
   9          volatile u8   fsm;
  10          volatile u8   us0_frash;
  11          volatile u8   us1_frash;
  12          volatile u16  us0_meas[4];
  13          volatile u16  us1_meas[4];
  14          volatile STRUCT_INT_CNT data st_x0;
  15          volatile STRUCT_INT_CNT data st_x1;
  16          volatile STRUCT_INT_CNT data st_t0;
  17          volatile STRUCT_INT_CNT data st_t1;
  18          volatile STRUCT_INT_CNT data *st_p;
  19          
  20          //---------------------------------------------------------------------------
  21          // Check struct increased by interrupt
  22          //---------------------------------------------------------------------------
  23          u8 inc_check (STRUCT_INT_CNT *p)
  24          {
  25   1          u8 cur;
  26   1          cur = p->cnt;
  27   1          if (cur > p->bak)       // normal increase
  28   1          {
  29   2              cur = cur - p->bak;
  30   2              p->bak = p->cnt;
  31   2          }
  32   1          else if (cur < p->bak)  // overflow increase
  33   1          {
  34   2              cur = 256 - p->bak + cur;
  35   2              p->bak = p->cnt;
  36   2          }
  37   1          else                    // no increase
  38   1          {
  39   2              cur = 0;
  40   2          }
  41   1          return cur;
  42   1      }
  43          
  44          //---------------------------------------------------------------------------
  45          // Initial System
  46          //---------------------------------------------------------------------------
  47          void sys_init (void)
  48          {
  49   1          // device init
  50   1          mcu_init ();
  51   1          LcdInit ();
  52   1          // parameter init
  53   1          st_x0.cnt = 0;
  54   1          st_x0.bak = 0;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/07/2018 15:49:20 PAGE 2   

  55   1          st_x1.cnt = 0;
  56   1          st_x1.bak = 0;
  57   1          st_t0.cnt = 0;
  58   1          st_t0.bak = 0;
  59   1          st_t1.cnt = 0;
  60   1          st_t1.bak = 0;
  61   1          us0_frash = 0;
  62   1          us1_frash = 0;
  63   1          us0_meas[0] = 0;
  64   1          us0_meas[1] = 0;
  65   1          us0_meas[2] = 0;
  66   1          us0_meas[3] = 0;
  67   1          us1_meas[0] = 0;
  68   1          us1_meas[1] = 0;
  69   1          us1_meas[2] = 0;
  70   1          us1_meas[3] = 0;
  71   1          time_ms = 0;
  72   1          time_qua = 0;
  73   1          time_sec = 0;
  74   1          us0_trig = 0;
  75   1          us1_trig = 0;
  76   1          EA = 1;
  77   1      }
  78          
  79          //---------------------------------------------------------------------------
  80          // Trigger one measurement of untrasonic 0
  81          //---------------------------------------------------------------------------
  82          #ifdef EN_US0
              void fsm_tus0_proc(void)
              {
                  u8 i, j;
                  // set 
                  time_ms = 0;
                  mcu_set_exint (INT_IDX_0, INT_MOD_START);
                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP );
                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_CAP  );
                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_50MS );
                  // start us0
                  us0_trig = 1;
                  DelayUs(100);
                  us0_trig = 0;
                  // detect
                  while (1)
                  {
                      // check response
                      i = inc_check (&st_x0);
                      if (i>0)
                      {
                          // stop
                          mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
                          mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
                          if (i==1)   // normal response
                          {
                              // backup response
                              for(j=0; j<3; j++)
                              {
                                  us0_meas[j+1] = us0_meas[j];
                              }
                              us0_meas[0] = (TH0<<8) + TL0;
                              us0_frash = 1;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/07/2018 15:49:20 PAGE 3   

                              // record time
                              time_ms = time_ms + (((TH1<<8) + TL1)*2)/1000;
                              // jump to next state
                              fsm = FSM_TUS1;
                              break;
                          }
                          else
                          {
                              // record time
                              time_ms = time_ms + (((TH1<<8) + TL0)*2)/1000;
                              // jump to error state
                              fsm = FSM_ERR_US0_MULTI_RESP;
                              break;
                          }
                      }
                      // check timeout
                      i = inc_check (&st_t1);
                      if (i>0)
                      {
                          // stop
                          mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
                          mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
                          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
                          time_ms = time_ms + 50;
                          fsm = FSM_ERR_US0_TIMEOUT;
                          break;
                      }
                  }
              }
              #else
 148          void fsm_tus0_proc(void)
 149          {
 150   1          time_ms = 0;
 151   1          fsm = FSM_TUS1;
 152   1      }
 153          #endif
 154          
 155          //---------------------------------------------------------------------------
 156          // Trigger one measurement of untrasonic 1
 157          //---------------------------------------------------------------------------
 158          #ifdef EN_US1
 159          void fsm_tus1_proc(void)
 160          {
 161   1          u8 i=0;
 162   1          // set 
 163   1      //    mcu_set_exint (INT_IDX_0, INT_MOD_STOP );
 164   1      //    mcu_set_exint (INT_IDX_1, INT_MOD_START);
 165   1      //    mcu_set_tmr   (TMR_IDX_0, TMR_MOD_50MS );
 166   1      //    mcu_set_tmr   (TMR_IDX_1, TMR_MOD_CAP  );
 167   1          mcu_set_exint (INT_IDX_0, INT_MOD_STOP );
 168   1          mcu_set_exint (INT_IDX_1, INT_MOD_STOP );
 169   1          mcu_set_tmr   (TMR_IDX_1, TMR_MOD_CAP  );
 170   1          TR1 = 1;
 171   1          // start us1
 172   1          us1_trig = 1;
 173   1          DelayUs(80);
 174   1          us1_trig = 0;
 175   1          //
 176   1      /*    while (1)
 177   1          {
 178   1      //        us1_echo = 1;
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/07/2018 15:49:20 PAGE 4   

 179   1      //        i = i+1;
 180   1              if (us1_echo)
 181   1              {
 182   1                  TR1 = 1;
 183   1                  break;
 184   1              }
 185   1          }*/
 186   1          // 
 187   1          DelayMs(50);
 188   1          while (1)
 189   1          {
 190   2              if (~us1_echo)
 191   2              {
 192   3                  us1_meas[0] = ((TH1<<8) + TL1);
 193   3                  fsm = FSM_WAIT;
 194   3                  TR1 = 0;
 195   3                  break;
 196   3              }
 197   2              if (TF1)
 198   2              {
 199   3                  fsm = FSM_ERR_US1_TIMEOUT;
 200   3                  TR1 = 0;
 201   3                  break;
 202   3              }
 203   2          }
 204   1      
 205   1      /*
 206   1          // detect
 207   1          while (1)
 208   1          {
 209   1              // check response
 210   1              i = inc_check (&st_x1);
 211   1              if (i>0)
 212   1              {
 213   1                  // stop
 214   1                  if (i==1)   // normal response
 215   1                  {
 216   1                      // backup response
 217   1                      for(j=0; j<3; j++)
 218   1                      {
 219   1                          us1_meas[j+1] = us1_meas[j];
 220   1                      }
 221   1                      us1_meas[0] = (TH1<<8) + TL1;
 222   1                      us1_frash = 1;
 223   1                      // record time
 224   1                      time_ms = time_ms + (((TH0<<8) + TL0)*2)/1000;
 225   1                      // jump to next state
 226   1                      mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
 227   1                      mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 228   1                      mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 229   1                      mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 230   1                      fsm = FSM_WAIT;
 231   1                      break;
 232   1                  }
 233   1                  else
 234   1                  {
 235   1                      // record time
 236   1                      time_ms = time_ms + (((TH0<<8) + TL0)*2)/1000;
 237   1                      // jump to error state
 238   1                      fsm = FSM_ERR_US1_MULTI_RESP;
 239   1                      break;
 240   1                  }
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/07/2018 15:49:20 PAGE 5   

 241   1              }
 242   1              // check timeout
 243   1              i = inc_check (&st_t0);
 244   1              if (i>0)
 245   1              {
 246   1                  // stop
 247   1                  mcu_set_exint (INT_IDX_0, INT_MOD_STOP);
 248   1                  mcu_set_exint (INT_IDX_1, INT_MOD_STOP);
 249   1                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 250   1                  mcu_set_tmr   (TMR_IDX_1, TMR_MOD_STOP);
 251   1                  time_ms = time_ms + 50;
 252   1                  fsm = FSM_ERR_US1_TIMEOUT;
 253   1                  break;
 254   1              }
 255   1          }
 256   1          */
 257   1      }
 258          #else
              void fsm_tus1_proc(void)
              {
                  time_ms = time_ms;
                  fsm = FSM_WAIT;
              }
              #endif
 265          
 266          //---------------------------------------------------------------------------
 267          // Wait for 250ms, and process the result of measurement
 268          //---------------------------------------------------------------------------
 269          void fsm_wait_proc(void)
 270          {
 271   1          u8 i, j;
 272   1          u16 len;
 273   1          // 250ms timer
 274   1          mcu_set_tmr   (TMR_IDX_0, TMR_MOD_10MS);
 275   1          TR0 = 1;
 276   1          ET0 = 1;
 277   1          while (1)
 278   1          {
 279   2              i = inc_check (&st_t0);
 280   2              time_ms = time_ms + i*10;
 281   2      //        if (time_ms > 250)
 282   2              if (time_ms > 1000)
 283   2              {
 284   3                  time_ms = 0;
 285   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 286   3      //            time_qua = time_qua + 1;
 287   3                  time_qua = 4;
 288   3                  break;
 289   3              }
 290   2          }
 291   1      #ifdef JOY_SYS_COMPAT
 292   1      //    LCD_BKL = ~LCD_BKL;
 293   1      #endif
 294   1          // frash flag
 295   1          us0_frash = 0;
 296   1          us1_frash = 0;
 297   1          // refrash display each second
 298   1          if (time_qua == 4)
 299   1          {
 300   2              time_qua = 0;
 301   2              time_sec = time_sec + 1;
 302   2              // display time
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/07/2018 15:49:20 PAGE 6   

 303   2              i = time_sec/10000 + '0';
 304   2              j = time_sec%10000;
 305   2              LcdDispChar (10, 1, 's');
 306   2              LcdDispChar (11, 1, 'e');
 307   2              LcdDispChar (12, 1, 'c');
 308   2              LcdDispChar (13, 1, ':');
 309   2              LcdDispChar (14, 1, i);
 310   2              i = j/1000 + '0';
 311   2              j = j%1000;
 312   2              LcdDispChar (15, 1, i);
 313   2              i = j/100 + '0';
 314   2              j = j%100;
 315   2              LcdDispChar (16, 1, i);
 316   2              i = j/10 + '0';
 317   2              j = j%10 + '0';
 318   2              LcdDispChar (17, 1, i);
 319   2              LcdDispChar (18, 1, j);
 320   2              // display us0
 321   2      //        len = (us0_meas[0] + us0_meas[1] + us0_meas[2] + us0_meas[3])/2;    // time in us
 322   2              len = us0_meas[0]*2;    // time in us
 323   2              len = len/2;        // single trace
 324   2              len = len/1000;     // time in ms
 325   2              len = len * 340;    // length in mm
 326   2              i = len/10000 + '0';
 327   2              j = len%10000;
 328   2              LcdDispChar (0, 0, i);
 329   2              i = j/1000 + '0';
 330   2              j = j%1000;
 331   2              LcdDispChar (1, 0, i);
 332   2              i = j/100 + '0';
 333   2              j = j%100;
 334   2              LcdDispChar (2, 0, i);
 335   2              i = j/10 + '0';
 336   2              j = j%10 + '0';
 337   2              LcdDispChar (3, 0, i);
 338   2              LcdDispChar (4, 0, j);
 339   2              LcdDispChar (5, 0, 'm');
 340   2              LcdDispChar (6, 0, 'm');
 341   2              // display us1
 342   2      //        len = (us1_meas[0] + us1_meas[1] + us1_meas[2] + us1_meas[3])/2;    // time in us
 343   2      
 344   2      //        len = us1_meas[0]*2;    // time in us
 345   2      //        len = len/2;        // single trace
 346   2      //        len = len/1000;     // time in ms
 347   2      //        len = len * 340;    // length in mm
 348   2              len = us1_meas[0];
 349   2              i = len/10000 + '0';
 350   2              j = len%10000;
 351   2              LcdDispChar (0, 1, i);
 352   2              i = j/1000 + '0';
 353   2              j = j%1000;
 354   2              LcdDispChar (1, 1, i);
 355   2              i = j/100 + '0';
 356   2              j = j%100;
 357   2              LcdDispChar (2, 1, i);
 358   2              i = j/10 + '0';
 359   2              j = j%10 + '0';
 360   2              LcdDispChar (3, 1, i);
 361   2              LcdDispChar (4, 1, j);
 362   2              LcdDispChar (5, 1, 'm');
 363   2              LcdDispChar (6, 1, 'm');
 364   2          }
C51 COMPILER V9.52.0.0   PROJ_LIB                                                          01/07/2018 15:49:20 PAGE 7   

 365   1          fsm = FSM_TUS0;
 366   1      }
 367          
 368          //---------------------------------------------------------------------------
 369          // Display Error Message
 370          //---------------------------------------------------------------------------
 371          void fsm_erro_proc(void)
 372          {
 373   1          u8 i;
 374   1          while (1)
 375   1          {
 376   2              i = inc_check (&st_t0);
 377   2              time_ms = time_ms + i*10;
 378   2              if (time_ms > 1000)
 379   2              {
 380   3                  time_ms = 0;
 381   3                  mcu_set_tmr   (TMR_IDX_0, TMR_MOD_STOP);
 382   3                  time_qua = 4;
 383   3                  break;
 384   3              }
 385   2          }
 386   1          // 1. clear screen
 387   1          for (i=0; i<16; i++)
 388   1              LcdDispChar (i, 0, ' ');
 389   1          for (i=0; i<16; i++)
 390   1              LcdDispChar (i, 1, ' ');
 391   1          // 2. display "FSM ERROR!"
 392   1          LcdDispString (0, 0, "FSM ERROR!!!");
 393   1          LcdDispChar (0, 1, 'f');
 394   1          LcdDispChar (1, 1, 's');
 395   1          LcdDispChar (2, 1, 'm');
 396   1          LcdDispChar (3, 1, ':');
 397   1          LcdDispChar (4, 1, ('0'+fsm/100));
 398   1          LcdDispChar (5, 1, ('0'+(fsm%100)/10));
 399   1          LcdDispChar (6, 1, ('0'+fsm%10));
 400   1          LcdDispChar (7, 1, 'd');
 401   1          // 3. stay here
 402   1          fsm = fsm;
 403   1      }
 404          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1083    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
