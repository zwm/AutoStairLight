US-100
测量距离2cm ~ 4.5m

距离        回响脉宽        T
1cm            59us         30
2cm           118us         59
4.5m           27ms         13235

MCU 1MHz -> 1us
    6MHz/12 -> 2us

MCU
CLK     6MHz
T0/1    6MHz/12 = 2us


65536*2 = 131072us = 131ms

// unit is mm
#define LEN_THRES           500

// int((LEN_THERS*2/1000)*(1/340)*1000*1000/2)
#define CNT_THRES           int(LEN_THRES*1000/340)

基本功能，每秒测量4次，或2次。
T0和T1分别连接两个计数器，工作时，T0测量模式，T1定时模式，然后T1测量模式，T0定时模式，完成后，总时间最长54ms。

T0测量开始，T1定时50ms，T1测量开始，T0定时50ms，延时150ms，如此循环即可！


Joy_sys平台测试
SRC     PIN     JOY         Connector
INT0    P3.2    SWITCH_GM   None
INT1    P3.3    KEY1        J2_4
GPIO    P3.4    KEY2        J2_5
GPIO    P3.7    KEY3        J2_6

US-100 5V 电平工作方式

Connection
JOY_SYS     US-100      DESCRIPTION
P3.4        Pin_2       Trigger
P3.3        Pin_3       Echo


20180108
1. trig port: change to mode 推挽输出
2. echo port: change to mode 输入模式
3. trig 单独设计函数，长度是大于10us，不能更长
4. 检查连线
5. 短接两个脚，测试程序下降沿触发功能！

20180109
昨天晚上从9点开始，调试到11点30，头脑很清醒，因为昨天晚上我因为头有点晕，就打游戏，没有调了。这么个小功能，却有这么大问题，我非常生气，昨天晚上在公司就已经想了几个方法了，晚上就开视频和博浩一块调试。我的debug刚开始就是测单片机，先测IO功能是否正常，结果IO都正常，再测定时器T1的功能，结果就发现T0正常，T1不行，T1寄存器读出来总是0，不管怎么控制，都不行，最后一次试的是直接读写T1寄存器，看是否正常，关了TR1，应该就是个普通寄存器，可这时屏不亮了，我改的程序肯定没问题，可能是片子坏了，也可能是博浩动到哪了，接插件不好使，不过好在的是他还有备用单片机，可以马上焊上，这个是他的强项，我就给他弄了，然后我就再改程序，编了很多版本测T1，换了片子，刚开始还是屏不亮，后来我让他把屏重插一下，结果就好了，然后T1就有反应了，昨天我想了很多很多种方法测，就是没怀疑到T1坏了，现在可以9成确定上一个单片机的T1有问题。我玩了这么多年的单片机，还是首次遇到这种问题的，真的是撞上大运了，单片机可以正常运行，T1坏掉了！！！
下一步调试计划
1. 把连接超声波的两个线加长到10m以上，看测距功能是否正常？根据测试结果，决定是否在两条线上添加驱动电路。
2. 总体框架需要改动，原来的测试US0，T1计时，测试US1，T0计时的方式，太过复杂，没必要做的那么精细，直接改成同时测US0和US1，等待250ms，这个模式，简单的就是最好的！

20180111
昨天晚上又调试了一下，增加了检测外部中断标志IE的程序，如果一次超声波测量后，外部中断标志位IE没有变成1，那么这是一次测量异常，需要做出处理。但就是这个小功能，昨天晚上调试了40分钟才成功。
BUG1：程序中增加的一次测量失败后，接下来三次不测量，这个宏定义在main.h中，因为总是检测不到IE，所以一秒只测一次，程序显示测量不准，乱数，我找到最后才发现是这个地方的问题。
BUG2：IE总是检测不到，我想不通，躺床上后，总算有点思路了。我的思路是，EX即使关了，IE还是会置位，这是我的印象，今天早上查资料，网上给的结构也是这样的。现在我想通了，STC单片机这个小地方的处理，可能是必须EX开了，才给IE置位，对应硬件实现是：
EX关，IE依然置位：
always @(posedge clk)
    if (falling_edge_ex_int)
        IE = 1;
    else if (handler_ex_int)
        IE = 0;
ex_int = IE & EX;
STC实现，EX关，IE不会置位：
always @(posedge clk)
    if (EX & falling_edge_ex_int)
        IE = 1;
    else if (handler_ex_int)
        IE = 0;
ex_int = IE;
这个还需要实际测试一下~
